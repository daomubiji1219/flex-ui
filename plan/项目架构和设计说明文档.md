# Flexi-UI 项目架构和设计说明文档

## 项目概述

Flexi-UI 是一个现代化的 React 组件库，采用 TypeScript 开发，基于 Emotion 样式系统，提供了一套完整的 UI 组件、Hooks 和工具函数。项目遵循现代前端开发最佳实践，注重性能、可维护性和开发体验。

### 核心特性

- **类型安全**：完整的 TypeScript 支持，提供优秀的开发体验
- **主题系统**：基于设计令牌的主题系统，支持亮色/暗色模式
- **高性能**：虚拟滚动、防抖节流、缓存优化等性能优化技术
- **设计模式**：应用多种设计模式，提高代码质量和可维护性
- **现代化工具链**：使用最新的前端开发工具和技术栈

## 技术架构

### 1. 整体架构图

```
flexi-ui/
├── src/
│   ├── components/          # UI 组件层
│   │   ├── Button/         # 按钮组件
│   │   ├── DataTable/      # 数据表格组件
│   │   ├── FileUploader/   # 文件上传组件
│   │   ├── VirtualList/    # 虚拟列表组件
│   │   └── ThemeToggle/    # 主题切换组件
│   ├── hooks/              # 自定义 Hooks 层
│   │   ├── useTheme.ts     # 主题管理
│   │   ├── useForm.ts      # 表单管理（基础版）
│   │   ├── useFormRefactored.ts # 表单管理（高级版）
│   │   └── useLocalStorage.ts   # 本地存储
│   ├── theme/              # 主题系统层
│   │   └── tokens.ts       # 设计令牌
│   ├── utils/              # 工具函数层
│   │   └── throttle.ts     # 节流函数
│   └── providers/          # Context 提供者层
│       └── ThemeProvider/  # 主题提供者
└── plan/                   # 文档目录
    ├── 组件详细说明文档.md
    ├── Hooks使用说明文档.md
    └── 项目架构和设计说明文档.md
```

### 2. 分层架构设计

#### 2.1 表现层（Presentation Layer）

- **组件层**：负责 UI 渲染和用户交互
- **样式层**：基于 Emotion 的 CSS-in-JS 解决方案
- **主题层**：统一的设计令牌和主题管理

#### 2.2 逻辑层（Business Logic Layer）

- **Hooks 层**：封装业务逻辑和状态管理
- **工具层**：提供通用的工具函数和算法
- **服务层**：处理数据获取和业务规则

#### 2.3 数据层（Data Layer）

- **状态管理**：基于 React Context 和 Hooks
- **缓存层**：LRU 缓存和本地存储
- **类型定义**：完整的 TypeScript 类型系统

## 技术选型

### 1. 核心技术栈

| 技术          | 版本 | 用途         | 选择理由                             |
| ------------- | ---- | ------------ | ------------------------------------ |
| React         | 18+  | UI 框架      | 现代化的组件化开发，优秀的生态系统   |
| TypeScript    | 5+   | 类型系统     | 提供类型安全，提升开发体验和代码质量 |
| Emotion       | 11+  | 样式解决方案 | CSS-in-JS，支持主题系统，性能优秀    |
| React Context | -    | 状态管理     | 轻量级状态管理，适合组件库场景       |

### 2. 开发工具

| 工具     | 用途       | 优势                     |
| -------- | ---------- | ------------------------ |
| ESLint   | 代码检查   | 保证代码质量和一致性     |
| Prettier | 代码格式化 | 统一代码风格             |
| Husky    | Git Hooks  | 提交前检查，保证代码质量 |
| Jest     | 单元测试   | 保证组件功能正确性       |

### 3. 构建工具

```json
{
  "scripts": {
    "build": "rollup -c",
    "dev": "storybook dev -p 6006",
    "test": "jest",
    "lint": "eslint src --ext .ts,.tsx",
    "type-check": "tsc --noEmit"
  }
}
```

## 设计原则

### 1. SOLID 原则应用

#### 1.1 单一职责原则（SRP）

每个组件和 Hook 都有明确的单一职责：

```typescript
// ✅ 单一职责：只负责主题管理
export const useTheme = (): ThemeContextValue => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

// ✅ 单一职责：只负责本地存储
export const useLocalStorage = <T>(key: string, initialValue: T) => {
  // 专注于本地存储逻辑
};
```

#### 1.2 开闭原则（OCP）

组件设计对扩展开放，对修改关闭：

```typescript
// Button 组件支持多种变体，易于扩展新变体
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost'; // 可扩展新变体
  size?: 'sm' | 'md' | 'lg'; // 可扩展新尺寸
  // 其他属性...
}

// 样式系统支持扩展
const variantStyles = {
  primary: css`...`,
  secondary: css`...`,
  // 可以轻松添加新变体而不修改现有代码
};
```

#### 1.3 里氏替换原则（LSP）

子类型可以替换父类型：

```typescript
// 所有表单验证器都实现相同接口
interface IValidator {
  validate: (value: unknown) => Promise<ValidationResult> | ValidationResult;
}

// 不同的验证器可以互相替换
class EmailValidator implements IValidator {
  validate(value: unknown): ValidationResult {
    // 邮箱验证逻辑
  }
}

class RequiredValidator implements IValidator {
  validate(value: unknown): ValidationResult {
    // 必填验证逻辑
  }
}
```

#### 1.4 接口隔离原则（ISP）

接口设计精简，避免强迫客户端依赖不需要的方法：

```typescript
// 分离不同的接口职责
interface IFormState<T> {
  values: T;
  errors: Partial<Record<keyof T, string>>;
  touched: Partial<Record<keyof T, boolean>>;
}

interface IFormActions<T> {
  setFieldValue: (name: keyof T, value: unknown) => void;
  validateField: (name: keyof T) => Promise<ValidationResult>;
  resetForm: () => void;
}

interface IFormObserver {
  onFieldChange?: (fieldName: string, value: unknown) => void;
  onFieldError?: (fieldName: string, error: string) => void;
}
```

#### 1.5 依赖倒置原则（DIP）

高层模块不依赖低层模块，都依赖抽象：

```typescript
// 高层模块依赖抽象接口
class FormFacade<T> {
  constructor(
    private stateManager: IStateManager<T>, // 依赖抽象
    private validator: IValidator, // 依赖抽象
    private observer: IObserver // 依赖抽象
  ) {}
}

// 具体实现可以替换
class LocalStorageStateManager<T> implements IStateManager<T> {
  // 具体实现
}

class MemoryStateManager<T> implements IStateManager<T> {
  // 具体实现
}
```

### 2. 设计模式应用

#### 2.1 外观模式（Facade Pattern）

简化复杂子系统的接口：

```typescript
// FormFacade 隐藏复杂的内部实现
export class FormFacade<T extends Record<string, unknown>> {
  private stateContext: FormStateContext;
  private observerManager: FormObserverManager;
  private commandInvoker: FormCommandInvoker;
  private validationCache: LRUCache<string, ValidationResult>;

  // 提供简单的公共接口
  async setFieldValue(fieldName: keyof T, value: unknown): Promise<void> {
    // 内部协调多个子系统
    const command = new SetFieldValueCommand(
      this.stateContext,
      String(fieldName),
      value
    );
    await this.commandInvoker.execute(command);
    this.observerManager.notifyFieldChange(String(fieldName), value);
  }
}
```

#### 2.2 命令模式（Command Pattern）

封装请求为对象，支持撤销/重做：

```typescript
interface ICommand {
  execute(): Promise<void>;
  undo(): Promise<void>;
}

class SetFieldValueCommand implements ICommand {
  constructor(
    private context: FormStateContext,
    private fieldName: string,
    private newValue: unknown,
    private oldValue?: unknown
  ) {}

  async execute(): Promise<void> {
    this.oldValue = this.context.getFieldValue(this.fieldName);
    this.context.setFieldValue(this.fieldName, this.newValue);
  }

  async undo(): Promise<void> {
    if (this.oldValue !== undefined) {
      this.context.setFieldValue(this.fieldName, this.oldValue);
    }
  }
}

class FormCommandInvoker {
  private history: ICommand[] = [];
  private currentIndex = -1;

  async execute(command: ICommand): Promise<void> {
    await command.execute();
    this.history = this.history.slice(0, this.currentIndex + 1);
    this.history.push(command);
    this.currentIndex++;
  }

  async undo(): Promise<void> {
    if (this.currentIndex >= 0) {
      await this.history[this.currentIndex].undo();
      this.currentIndex--;
    }
  }
}
```

#### 2.3 观察者模式（Observer Pattern）

实现发布-订阅机制：

```typescript
interface IFormObserver {
  onFieldChange?: (fieldName: string, value: unknown) => void;
  onFieldError?: (fieldName: string, error: string) => void;
  onFormSubmit?: (values: Record<string, unknown>) => void;
}

class FormObserverManager {
  private observers: IFormObserver[] = [];

  subscribe(observer: IFormObserver): () => void {
    this.observers.push(observer);
    return () => {
      const index = this.observers.indexOf(observer);
      if (index > -1) {
        this.observers.splice(index, 1);
      }
    };
  }

  notifyFieldChange(fieldName: string, value: unknown): void {
    this.observers.forEach(observer => {
      observer.onFieldChange?.(fieldName, value);
    });
  }

  notifyFieldError(fieldName: string, error: string): void {
    this.observers.forEach(observer => {
      observer.onFieldError?.(fieldName, error);
    });
  }
}
```

#### 2.4 状态模式（State Pattern）

管理对象在不同状态下的行为：

```typescript
abstract class FormState {
  abstract handleSubmit(context: FormStateContext): Promise<void>;
  abstract handleValidation(context: FormStateContext): Promise<void>;
  abstract canEdit(): boolean;
}

class IdleFormState extends FormState {
  async handleSubmit(context: FormStateContext): Promise<void> {
    context.setState(new SubmittingFormState());
    // 执行提交逻辑
  }

  async handleValidation(context: FormStateContext): Promise<void> {
    // 执行验证逻辑
  }

  canEdit(): boolean {
    return true;
  }
}

class SubmittingFormState extends FormState {
  async handleSubmit(context: FormStateContext): Promise<void> {
    console.warn('表单正在提交中，请稍候...');
  }

  async handleValidation(context: FormStateContext): Promise<void> {
    // 提交中不执行验证
  }

  canEdit(): boolean {
    return false;
  }
}

class FormStateContext {
  private state: FormState;

  constructor(initialState: FormState) {
    this.state = initialState;
  }

  setState(state: FormState): void {
    this.state = state;
  }

  async submit(): Promise<void> {
    await this.state.handleSubmit(this);
  }

  canEdit(): boolean {
    return this.state.canEdit();
  }
}
```

#### 2.5 策略模式（Strategy Pattern）

封装算法族，使它们可以互相替换：

```typescript
// 验证策略接口
interface IValidationStrategy {
  validate(value: unknown): Promise<ValidationResult>;
}

// 具体验证策略
class EmailValidationStrategy implements IValidationStrategy {
  async validate(value: unknown): Promise<ValidationResult> {
    if (typeof value !== 'string') {
      return { isValid: false, message: '邮箱必须是字符串' };
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(value)) {
      return { isValid: false, message: '邮箱格式不正确' };
    }

    return { isValid: true };
  }
}

class RequiredValidationStrategy implements IValidationStrategy {
  async validate(value: unknown): Promise<ValidationResult> {
    if (value === null || value === undefined || value === '') {
      return { isValid: false, message: '此字段为必填项' };
    }
    return { isValid: true };
  }
}

// 验证器上下文
class FieldValidator {
  private strategies: IValidationStrategy[] = [];

  addStrategy(strategy: IValidationStrategy): void {
    this.strategies.push(strategy);
  }

  async validate(value: unknown): Promise<ValidationResult[]> {
    const results = await Promise.all(
      this.strategies.map(strategy => strategy.validate(value))
    );
    return results;
  }
}
```

### 3. 组件设计原则

#### 3.1 组合优于继承

使用组合模式构建复杂组件：

```typescript
// ✅ 使用组合
const DataTable = <T,>({ columns, data, ...props }: DataTableProps<T>) => {
  return (
    <TableContainer>
      <TableHeader columns={columns} />
      <TableBody data={data} columns={columns} />
      <TableFooter />
    </TableContainer>
  );
};

// ❌ 避免深层继承
class BaseTable extends Component { }
class SortableTable extends BaseTable { }
class FilterableTable extends SortableTable { }
```

#### 3.2 控制反转（IoC）

通过 props 和 render props 实现控制反转：

```typescript
// 通过 render props 实现控制反转
interface DataTableProps<T> {
  data: T[];
  renderRow?: (item: T, index: number) => React.ReactNode;
  renderEmpty?: () => React.ReactNode;
  renderLoading?: () => React.ReactNode;
}

const DataTable = <T,>({ data, renderRow, renderEmpty, renderLoading }: DataTableProps<T>) => {
  if (loading) {
    return renderLoading ? renderLoading() : <DefaultLoading />;
  }

  if (data.length === 0) {
    return renderEmpty ? renderEmpty() : <DefaultEmpty />;
  }

  return (
    <div>
      {data.map((item, index) =>
        renderRow ? renderRow(item, index) : <DefaultRow key={index} item={item} />
      )}
    </div>
  );
};
```

#### 3.3 关注点分离

将样式、逻辑、数据分离：

```typescript
// 逻辑层：hooks
const useButtonLogic = (props: ButtonProps) => {
  const [loading, setLoading] = useState(props.loading || false);

  const handleClick = useCallback(async (e: React.MouseEvent) => {
    if (loading || props.disabled) return;

    if (props.onClick) {
      setLoading(true);
      try {
        await props.onClick(e);
      } finally {
        setLoading(false);
      }
    }
  }, [loading, props.disabled, props.onClick]);

  return { loading, handleClick };
};

// 样式层：styled components
const StyledButton = styled.button<ButtonStyleProps>`
  ${baseButtonStyles}
  ${({ variant }) => variantStyles[variant]}
  ${({ size }) => sizeStyles[size]}
`;

// 表现层：组件
const Button = forwardRef<HTMLButtonElement, ButtonProps>((props, ref) => {
  const { loading, handleClick } = useButtonLogic(props);

  return (
    <StyledButton
      ref={ref}
      onClick={handleClick}
      disabled={props.disabled || loading}
      variant={props.variant}
      size={props.size}
    >
      {loading && <Spinner />}
      {props.icon && <IconContainer>{props.icon}</IconContainer>}
      {props.children}
    </StyledButton>
  );
});
```

## 性能优化策略

### 1. 渲染优化

#### 1.1 虚拟滚动

对于大量数据的列表，使用虚拟滚动技术：

```typescript
const VirtualList = <T,>({ items, itemHeight, containerHeight }: VirtualListProps<T>) => {
  const [scrollTop, setScrollTop] = useState(0);

  const visibleItems = useMemo(() => {
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(containerHeight / itemHeight) + 1,
      items.length
    );

    return items.slice(startIndex, endIndex).map((item, index) => ({
      item,
      index: startIndex + index,
      top: (startIndex + index) * itemHeight,
    }));
  }, [items, itemHeight, containerHeight, scrollTop]);

  return (
    <div
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        {visibleItems.map(({ item, index, top }) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              top,
              height: itemHeight,
              width: '100%',
            }}
          >
            {renderItem(item, index)}
          </div>
        ))}
      </div>
    </div>
  );
};
```

#### 1.2 React.memo 和 useMemo

避免不必要的重渲染：

```typescript
// 使用 React.memo 优化组件
const TableRow = React.memo<TableRowProps>(({ data, columns }) => {
  return (
    <tr>
      {columns.map(column => (
        <td key={column.key}>
          {column.render ? column.render(data[column.key], data) : data[column.key]}
        </td>
      ))}
    </tr>
  );
});

// 使用 useMemo 缓存计算结果
const DataTable = <T,>({ data, columns, sortBy, filterBy }: DataTableProps<T>) => {
  const processedData = useMemo(() => {
    let result = [...data];

    // 过滤
    if (filterBy) {
      result = result.filter(filterBy);
    }

    // 排序
    if (sortBy) {
      result.sort(sortBy);
    }

    return result;
  }, [data, sortBy, filterBy]);

  return (
    <table>
      <tbody>
        {processedData.map((row, index) => (
          <TableRow key={index} data={row} columns={columns} />
        ))}
      </tbody>
    </table>
  );
};
```

### 2. 网络优化

#### 2.1 文件分块上传

大文件分块上传，提高上传成功率：

```typescript
const CHUNK_SIZE = 1024 * 1024; // 1MB

const uploadFileInChunks = async (file: File): Promise<void> => {
  const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
  const fileHash = await generateFileHash(file);

  // 检查已上传的分块
  const uploadedChunks = await checkUploadedChunks(fileHash);

  for (let i = 0; i < totalChunks; i++) {
    if (uploadedChunks.includes(i)) {
      continue; // 跳过已上传的分块
    }

    const start = i * CHUNK_SIZE;
    const end = Math.min(start + CHUNK_SIZE, file.size);
    const chunk = file.slice(start, end);

    await uploadChunk(chunk, i, fileHash);
  }

  // 合并分块
  await mergeChunks(fileHash, totalChunks);
};
```

#### 2.2 请求防抖和节流

避免频繁的网络请求：

```typescript
// 搜索防抖
const useSearch = (query: string, delay: number = 300) => {
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);

  const debouncedSearch = useMemo(
    () =>
      debounce(async (searchQuery: string) => {
        if (!searchQuery.trim()) {
          setResults([]);
          return;
        }

        setLoading(true);
        try {
          const response = await fetch(
            `/api/search?q=${encodeURIComponent(searchQuery)}`
          );
          const data = await response.json();
          setResults(data);
        } catch (error) {
          console.error('搜索失败:', error);
        } finally {
          setLoading(false);
        }
      }, delay),
    [delay]
  );

  useEffect(() => {
    debouncedSearch(query);
  }, [query, debouncedSearch]);

  return { results, loading };
};
```

### 3. 缓存策略

#### 3.1 LRU 缓存

缓存验证结果和计算结果：

```typescript
class LRUCache<K, V> {
  private cache = new Map<K, V>();
  private maxSize: number;

  constructor(maxSize: number) {
    this.maxSize = maxSize;
  }

  get(key: K): V | undefined {
    if (this.cache.has(key)) {
      const value = this.cache.get(key)!;
      // 移到最后（最近使用）
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return undefined;
  }

  set(key: K, value: V): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // 删除最久未使用的项
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }

  clear(): void {
    this.cache.clear();
  }
}

// 在表单验证中使用缓存
const validationCache = new LRUCache<string, ValidationResult>(100);

const validateWithCache = async (
  fieldName: string,
  value: unknown
): Promise<ValidationResult> => {
  const cacheKey = `${fieldName}:${JSON.stringify(value)}`;

  // 尝试从缓存获取
  const cached = validationCache.get(cacheKey);
  if (cached) {
    return cached;
  }

  // 执行验证
  const result = await performValidation(fieldName, value);

  // 缓存结果
  validationCache.set(cacheKey, result);

  return result;
};
```

#### 3.2 本地存储缓存

利用 localStorage 缓存用户偏好和状态：

```typescript
const usePersistedState = <T>(key: string, defaultValue: T) => {
  const [state, setState] = useState<T>(() => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch {
      return defaultValue;
    }
  });

  const setPersistedState = useCallback(
    (value: T | ((prev: T) => T)) => {
      setState(prevState => {
        const newState =
          typeof value === 'function'
            ? (value as (prev: T) => T)(prevState)
            : value;

        try {
          localStorage.setItem(key, JSON.stringify(newState));
        } catch (error) {
          console.error('Failed to save to localStorage:', error);
        }

        return newState;
      });
    },
    [key]
  );

  return [state, setPersistedState] as const;
};
```

## 主题系统设计

### 1. 设计令牌（Design Tokens）

设计令牌是设计系统的基础，定义了颜色、字体、间距等设计元素：

```typescript
export const designTokens = {
  // 颜色系统
  colors: {
    primary: {
      50: '#eff6ff',
      100: '#dbeafe',
      500: '#3b82f6',
      900: '#1e3a8a',
    },
    neutral: {
      50: '#f9fafb',
      100: '#f3f4f6',
      500: '#6b7280',
      900: '#111827',
    },
    // 语义化颜色
    semantic: {
      success: '#10b981',
      warning: '#f59e0b',
      error: '#ef4444',
      info: '#3b82f6',
    },
  },

  // 间距系统
  spacing: {
    xs: '0.25rem', // 4px
    sm: '0.5rem', // 8px
    md: '1rem', // 16px
    lg: '1.5rem', // 24px
    xl: '2rem', // 32px
  },

  // 字体系统
  typography: {
    fonts: {
      sans: ['Inter', 'system-ui', 'sans-serif'],
      mono: ['Fira Code', 'monospace'],
    },
    sizes: {
      xs: '0.75rem', // 12px
      sm: '0.875rem', // 14px
      base: '1rem', // 16px
      lg: '1.125rem', // 18px
      xl: '1.25rem', // 20px
    },
    weights: {
      normal: 400,
      medium: 500,
      semibold: 600,
      bold: 700,
    },
  },

  // 阴影系统
  shadows: {
    sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',
    md: '0 4px 6px -1px rgb(0 0 0 / 0.1)',
    lg: '0 10px 15px -3px rgb(0 0 0 / 0.1)',
  },

  // 圆角系统
  radii: {
    none: '0',
    sm: '0.125rem', // 2px
    md: '0.375rem', // 6px
    lg: '0.5rem', // 8px
    full: '9999px',
  },

  // 过渡动画
  transitions: {
    fast: '150ms ease-in-out',
    normal: '250ms ease-in-out',
    slow: '350ms ease-in-out',
  },
} as const;
```

### 2. 主题提供者

基于 React Context 的主题系统：

```typescript
interface ThemeContextValue {
  theme: Theme;
  mode: ThemeMode;
  toggleMode: () => void;
  setMode: (mode: ThemeMode) => void;
}

const ThemeContext = createContext<ThemeContextValue | null>(null);

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [mode, setMode] = usePersistedState<ThemeMode>('theme-mode', 'light');

  const theme = useMemo(() => createTheme(mode), [mode]);

  const toggleMode = useCallback(() => {
    setMode(prevMode => prevMode === 'light' ? 'dark' : 'light');
  }, [setMode]);

  const contextValue = useMemo(() => ({
    theme,
    mode,
    toggleMode,
    setMode,
  }), [theme, mode, toggleMode, setMode]);

  return (
    <ThemeContext.Provider value={contextValue}>
      <ThemeProvider theme={theme}>
        {children}
      </ThemeProvider>
    </ThemeContext.Provider>
  );
};

// 创建主题对象
const createTheme = (mode: ThemeMode): Theme => {
  const isDark = mode === 'dark';

  return {
    tokens: designTokens,
    mode,
    isDark,
    colors: {
      primary: designTokens.colors.primary,
      secondary: designTokens.colors.secondary,
      background: isDark ? designTokens.colors.neutral[900] : designTokens.colors.neutral[50],
      surface: isDark ? designTokens.colors.neutral[800] : '#ffffff',
      text: {
        primary: isDark ? designTokens.colors.neutral[100] : designTokens.colors.neutral[900],
        secondary: isDark ? designTokens.colors.neutral[300] : designTokens.colors.neutral[600],
        disabled: isDark ? designTokens.colors.neutral[500] : designTokens.colors.neutral[400],
      },
      border: isDark ? designTokens.colors.neutral[700] : designTokens.colors.neutral[200],
    },
  };
};
```

### 3. 样式系统

基于 Emotion 的 CSS-in-JS 解决方案：

```typescript
// 基础样式
const baseButtonStyles = css`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: none;
  border-radius: ${designTokens.radii.md};
  font-family: ${designTokens.typography.fonts.sans.join(', ')};
  font-weight: ${designTokens.typography.weights.medium};
  cursor: pointer;
  transition: ${designTokens.transitions.normal};

  &:disabled {
    cursor: not-allowed;
    opacity: 0.6;
  }

  &:focus-visible {
    outline: 2px solid ${designTokens.colors.primary[500]};
    outline-offset: 2px;
  }
`;

// 尺寸变体
const sizeStyles = {
  sm: css`
    height: 2rem;
    padding: 0 ${designTokens.spacing.sm};
    font-size: ${designTokens.typography.sizes.sm};
  `,
  md: css`
    height: 2.5rem;
    padding: 0 ${designTokens.spacing.md};
    font-size: ${designTokens.typography.sizes.base};
  `,
  lg: css`
    height: 3rem;
    padding: 0 ${designTokens.spacing.lg};
    font-size: ${designTokens.typography.sizes.lg};
  `,
};

// 主题感知的变体样式
const variantStyles = {
  primary: (theme: Theme) => css`
    background-color: ${theme.colors.primary[500]};
    color: white;

    &:hover:not(:disabled) {
      background-color: ${theme.colors.primary[600]};
    }

    &:active:not(:disabled) {
      background-color: ${theme.colors.primary[700]};
    }
  `,
  secondary: (theme: Theme) => css`
    background-color: ${theme.colors.surface};
    color: ${theme.colors.text.primary};
    border: 1px solid ${theme.colors.border};

    &:hover:not(:disabled) {
      background-color: ${theme.isDark
        ? theme.colors.neutral[700]
        : theme.colors.neutral[100]};
    }
  `,
};

// 样式化组件
const StyledButton = styled.button<ButtonStyleProps>`
  ${baseButtonStyles}
  ${({ size }) => sizeStyles[size]}
  ${({ variant, theme }) => variantStyles[variant](theme)}
`;
```

## 测试策略

### 1. 单元测试

使用 Jest 和 React Testing Library 进行组件测试：

```typescript
// Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { ThemeProvider } from '../providers/ThemeProvider';
import { Button } from './Button';

const renderWithTheme = (component: React.ReactElement) => {
  return render(
    <ThemeProvider>
      {component}
    </ThemeProvider>
  );
};

describe('Button', () => {
  it('renders correctly', () => {
    renderWithTheme(<Button>Click me</Button>);
    expect(screen.getByRole('button', { name: 'Click me' })).toBeInTheDocument();
  });

  it('handles click events', () => {
    const handleClick = jest.fn();
    renderWithTheme(<Button onClick={handleClick}>Click me</Button>);

    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('shows loading state', () => {
    renderWithTheme(<Button loading>Click me</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
    expect(screen.getByTestId('spinner')).toBeInTheDocument();
  });

  it('applies variant styles correctly', () => {
    renderWithTheme(<Button variant="primary">Primary</Button>);
    const button = screen.getByRole('button');
    expect(button).toHaveClass('primary-variant');
  });
});
```

### 2. 集成测试

测试组件之间的交互：

```typescript
// DataTable.integration.test.tsx
describe('DataTable Integration', () => {
  const mockData = [
    { id: 1, name: 'John', email: 'john@example.com' },
    { id: 2, name: 'Jane', email: 'jane@example.com' },
  ];

  const columns = [
    { key: 'name', title: 'Name', sortable: true },
    { key: 'email', title: 'Email', sortable: true },
  ];

  it('sorts data when column header is clicked', async () => {
    renderWithTheme(
      <DataTable data={mockData} columns={columns} />
    );

    // 点击名称列标题进行排序
    fireEvent.click(screen.getByText('Name'));

    // 验证排序结果
    const rows = screen.getAllByRole('row');
    expect(rows[1]).toHaveTextContent('Jane');
    expect(rows[2]).toHaveTextContent('John');
  });

  it('filters data when search input changes', async () => {
    renderWithTheme(
      <DataTable data={mockData} columns={columns} searchable />
    );

    const searchInput = screen.getByPlaceholderText('搜索...');
    fireEvent.change(searchInput, { target: { value: 'John' } });

    // 等待防抖完成
    await waitFor(() => {
      expect(screen.getAllByRole('row')).toHaveLength(2); // 1 header + 1 data row
    });
  });
});
```

### 3. 性能测试

测试组件的性能表现：

```typescript
// VirtualList.performance.test.tsx
describe('VirtualList Performance', () => {
  it('renders large datasets efficiently', () => {
    const largeDataset = Array.from({ length: 10000 }, (_, i) => ({
      id: i,
      name: `Item ${i}`,
    }));

    const startTime = performance.now();

    renderWithTheme(
      <VirtualList
        items={largeDataset}
        itemHeight={50}
        containerHeight={400}
        renderItem={(item) => <div key={item.id}>{item.name}</div>}
      />
    );

    const endTime = performance.now();
    const renderTime = endTime - startTime;

    // 渲染时间应该小于 100ms
    expect(renderTime).toBeLessThan(100);

    // 只渲染可见的项目
    const renderedItems = screen.getAllByText(/Item \d+/);
    expect(renderedItems.length).toBeLessThan(20); // 远少于 10000 个项目
  });
});
```

### 4. 可访问性测试

确保组件符合 WCAG 标准：

```typescript
// accessibility.test.tsx
import { axe, toHaveNoViolations } from 'jest-axe';

expect.extend(toHaveNoViolations);

describe('Accessibility', () => {
  it('Button should not have accessibility violations', async () => {
    const { container } = renderWithTheme(
      <Button variant="primary">Accessible Button</Button>
    );

    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('DataTable should be keyboard navigable', () => {
    renderWithTheme(
      <DataTable data={mockData} columns={columns} />
    );

    const table = screen.getByRole('table');
    expect(table).toHaveAttribute('tabIndex', '0');

    // 测试键盘导航
    fireEvent.keyDown(table, { key: 'ArrowDown' });
    expect(screen.getByRole('row', { selected: true })).toBeInTheDocument();
  });
});
```

## 构建和部署

### 1. 构建配置

使用 Rollup 构建组件库：

```javascript
// rollup.config.js
import typescript from '@rollup/plugin-typescript';
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import peerDepsExternal from 'rollup-plugin-peer-deps-external';
import { terser } from 'rollup-plugin-terser';

export default {
  input: 'src/index.ts',
  output: [
    {
      file: 'dist/index.cjs.js',
      format: 'cjs',
      sourcemap: true,
    },
    {
      file: 'dist/index.esm.js',
      format: 'esm',
      sourcemap: true,
    },
  ],
  plugins: [
    peerDepsExternal(),
    resolve({
      browser: true,
    }),
    commonjs(),
    typescript({
      tsconfig: './tsconfig.build.json',
    }),
    terser(),
  ],
  external: ['react', 'react-dom', '@emotion/react', '@emotion/styled'],
};
```

### 2. 包配置

```json
{
  "name": "flexi-ui",
  "version": "1.0.0",
  "description": "A modern React component library",
  "main": "dist/index.cjs.js",
  "module": "dist/index.esm.js",
  "types": "dist/index.d.ts",
  "files": ["dist"],
  "peerDependencies": {
    "react": ">=16.8.0",
    "react-dom": ">=16.8.0",
    "@emotion/react": "^11.0.0",
    "@emotion/styled": "^11.0.0"
  },
  "devDependencies": {
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "typescript": "^5.0.0",
    "rollup": "^3.0.0"
  }
}
```

### 3. CI/CD 流程

```yaml
# .github/workflows/ci.yml
name: CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Run type check
        run: pnpm type-check

      - name: Run linting
        run: pnpm lint

      - name: Run tests
        run: pnpm test --coverage

      - name: Upload coverage
        uses: codecov/codecov-action@v3

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Build package
        run: pnpm build

      - name: Publish to NPM
        if: github.ref == 'refs/heads/main'
        run: pnpm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

## 文档系统

### 1. Storybook 集成

使用 Storybook 展示组件：

```typescript
// Button.stories.tsx
import type { Meta, StoryObj } from '@storybook/react';
import { Button } from './Button';

const meta: Meta<typeof Button> = {
  title: 'Components/Button',
  component: Button,
  parameters: {
    layout: 'centered',
  },
  tags: ['autodocs'],
  argTypes: {
    variant: {
      control: { type: 'select' },
      options: ['primary', 'secondary', 'outline', 'ghost'],
    },
    size: {
      control: { type: 'select' },
      options: ['sm', 'md', 'lg'],
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {
  args: {
    variant: 'primary',
    children: 'Button',
  },
};

export const Secondary: Story = {
  args: {
    variant: 'secondary',
    children: 'Button',
  },
};

export const Loading: Story = {
  args: {
    variant: 'primary',
    loading: true,
    children: 'Loading...',
  },
};

export const WithIcon: Story = {
  args: {
    variant: 'primary',
    icon: <PlusIcon />,
    children: 'Add Item',
  },
};
```

### 2. 自动生成文档

使用 TypeDoc 生成 API 文档：

```json
{
  "scripts": {
    "docs:generate": "typedoc src/index.ts --out docs --theme default",
    "docs:serve": "serve docs"
  }
}
```

## 最佳实践总结

### 1. 代码质量

- **类型安全**：使用 TypeScript 确保类型安全
- **代码规范**：使用 ESLint 和 Prettier 保持代码一致性
- **测试覆盖**：保持高测试覆盖率，包括单元测试、集成测试和可访问性测试
- **文档完善**：提供详细的 API 文档和使用示例

### 2. 性能优化

- **虚拟化**：对大量数据使用虚拟滚动
- **缓存策略**：合理使用缓存减少重复计算
- **防抖节流**：避免频繁的操作和请求
- **代码分割**：按需加载组件和功能

### 3. 可维护性

- **设计模式**：应用合适的设计模式提高代码质量
- **关注点分离**：将样式、逻辑、数据分离
- **组合优于继承**：使用组合模式构建复杂组件
- **接口设计**：设计简洁、一致的 API 接口

### 4. 用户体验

- **可访问性**：遵循 WCAG 标准，支持键盘导航和屏幕阅读器
- **主题系统**：提供完整的主题定制能力
- **响应式设计**：适配不同屏幕尺寸和设备
- **加载状态**：提供清晰的加载和错误状态反馈

### 5. 开发体验

- **TypeScript 支持**：提供完整的类型定义
- **开发工具**：集成 Storybook、热重载等开发工具
- **文档齐全**：提供详细的使用文档和示例
- **版本管理**：遵循语义化版本控制

## 未来规划

### 1. 功能扩展

- **更多组件**：添加更多常用的 UI 组件
- **动画系统**：集成动画库，提供丰富的动画效果
- **图表组件**：添加数据可视化组件
- **表单构建器**：提供可视化的表单构建工具

### 2. 性能优化

- **Bundle 优化**：进一步减小包体积
- **运行时优化**：优化组件渲染性能
- **内存管理**：优化内存使用，避免内存泄漏
- **Web Workers**：在适当场景使用 Web Workers

### 3. 开发体验

- **CLI 工具**：提供命令行工具快速创建项目
- **VS Code 插件**：提供代码提示和自动补全
- **设计工具集成**：与 Figma 等设计工具集成
- **代码生成**：自动生成组件模板和样板代码

### 4. 生态建设

- **社区贡献**：建立开源社区，接受外部贡献
- **插件系统**：提供插件机制，支持第三方扩展
- **最佳实践**：总结和分享最佳实践
- **培训材料**：提供学习资源和培训材料

## 结论

Flexi-UI 项目展示了现代 React 组件库的完整架构设计，通过应用设计模式、性能优化技术和最佳实践，构建了一个高质量、可维护、易扩展的组件库。项目不仅提供了丰富的 UI 组件和工具函数，还展示了如何在实际项目中应用高级的软件工程概念。

这个架构设计为团队提供了：

- **清晰的代码组织结构**
- **一致的开发规范**
- **高效的开发流程**
- **优秀的用户体验**
- **良好的可维护性**

通过持续的迭代和优化，Flexi-UI 将继续演进，为开发者提供更好的工具和体验。
