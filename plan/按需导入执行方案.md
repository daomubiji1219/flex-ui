# Flexi-UI 按需导入执行方案（修订版）

结合当前项目实际（存在 src/compoents、部分组件使用独立 CSS、现有 Rollup 单入口构建与独立类型产物脚本），对先前方案做出以下修正与落地指引。

## 0. 总体目标

- 保持“手动导入 + 原生 ESM Tree-shaking”的核心理念
- 兼容现有全量导入，同时支持子路径按需导入
- 不强制一次性迁移到 CSS-in-JS，允许渐进过渡

## 1. 目录与命名（两种落地路径）

- A 直接更名（推荐在较少分支改动时进行）
  - 使用 PowerShell：Rename-Item -Path "src/compoents" -NewName "components"
  - 或使用 Git：git mv src\compoents src\components
  - 更名后，逐步修正项目内部引用路径与 tsconfig.lib.json 的 include 路径
- B 别名过渡（低风险增量调整）
  - 新建 src/components/{X}/index.ts，仅从旧路径 re-export（避免大规模重命名）
  - 例如：export { default } from "../../compoents/Button/Button";

建议优先采用 B（别名过渡），稳定后再统一重命名。

## 2. CSS 与 sideEffects 的关键修正

- 由于 FileUploader 等组件存在独立 .css 文件，package.json 不应设置 "sideEffects": false
- 推荐配置："sideEffects": ["**/*.css"]（保留样式的副作用，避免被错误摇树）
- Rollup 的 postcss 继续使用 extract: true，维持当前聚合 CSS 的产物形态；CSS-in-JS 作为中长期优化方向，而非当下强制项

## 3. 构建策略：双配置并存，兼容 + 按需

- 配置 A（兼容产物）：
  - 单入口 input: src/index.ts
  - 输出：dist/index.cjs.js 与 dist/index.esm.js（延续现有 main/module 指向）
  - 不开启 preserveModules（保持单文件产物）
- 配置 B（按需产物）：
  - 多入口（按组件/Hook/主题入口），启用 preserveModules: true
  - 输出目录分别为：dist/esm 与 dist/cjs（避免与配置 A 产物冲突）
  - entryFileNames：ESM 用 [name].js，CJS 用 [name].cjs
  - preserveModulesRoot: "src"（保留 src 下的子目录结构）
- 多入口收集：使用 glob 收集 "src/components/\*/index.ts" 等路径
  - 解析组件名时不要用正则匹配路径分隔符，使用 Node path：
    - const name = path.basename(path.dirname(entry))
- 依赖：新增 devDependency "glob"

## 4. Exports 字段（与双目录产物对应）

- 顶层：
  - ".": {
    - import: "./dist/index.esm.js"
    - require: "./dist/index.cjs.js"
    - types: "./dist/index.d.ts"
      }
- 子路径（示例）：
  - "./Button": {
    - import: "./dist/esm/components/Button/index.js"
    - require: "./dist/cjs/components/Button/index.cjs"
    - types: "./dist/types/components/Button/index.d.ts"
      }
  - 针对 DataTable、FileUploader、VirtualList 依此类推
- Hooks 出口建议：两种方案
  - 逐个导出（无需新增聚合文件），例如 "./hooks/useTheme"、"./hooks/useLocalStorage"
  - 或新增 src/hooks/index.ts 聚合后导出 "./hooks"（需要新增文件）

## 5. TypeScript 产物与配置

- 纠正：先前方案中将 "preserveModules" 放入 tsconfig 是错误的，该选项属于 Rollup 输出层
- 保持现有类型产物流程：通过 tsconfig.lib.json 与脚本独立产出声明文件（pnpm run build:types）
- 若后续重命名为 components，务必同步更新 tsconfig.lib.json 的 include 路径（由 src/compoents/**/\* 改为 src/components/**/\*）
- 在 ts/tsx 文件中继续使用显式 type 导入规范（import type { ... } from "..."）

## 6. 用户导入方式（保持不变 + 新增能力）

- 按需导入（新能力）：
  - import Button from "@daomu/flexi-ui/Button"
- 全量导入（兼容既有）：
  - import { Button, DataTable } from "@daomu/flexi-ui"

## 7. 落地步骤（建议顺序）

1. 选择目录策略：优先“别名过渡”，后续集中重命名
2. 新增 dev 依赖：pnpm add -D glob
3. 将 Rollup 配置拆分为数组导出（配置 A + 配置 B），并使用 dist/esm 与 dist/cjs 避免冲突
4. 更新 package.json：添加 exports；设置 sideEffects 为 ["**/*.css"]
5. 如采用重命名，更新 tsconfig.lib.json 的 include 路径
6. 执行构建校验：
   - pnpm run build:lib
   - pnpm run build:types
   - 在示例/外部项目中验证子路径导入可用，且未使用组件不会被打包

## 8. 风险与对策

- CSS 丢失风险：通过 sideEffects 针对 "\*_/_.css" 保底；仍建议在每个使用 CSS 的组件内显式 import 其样式
- 产物冲突风险：按需产物输出到 dist/esm 与 dist/cjs，避免覆盖 dist 根目录的主入口文件
- 渐进迁移：先提供别名与子路径导出能力，再择机统一更名与样式方案

以上修订使方案完全贴合当前仓库现状，减少一次性重构风险，同时实现按需导入与 Tree-shaking 的目标。
