# Flexi-UI 样式扩展性最佳实践指南

## 概述

本指南提供了在 Flexi-UI 组件库中进行样式扩展和定制的最佳实践，帮助开发者充分利用现有的样式系统，同时避免常见的陷阱和性能问题。

## 目录

1. [样式扩展策略](#样式扩展策略)
2. [主题定制指南](#主题定制指南)
3. [组件样式覆盖](#组件样式覆盖)
4. [性能优化建议](#性能优化建议)
5. [常见问题解决](#常见问题解决)
6. [开发工具和调试](#开发工具和调试)

## 样式扩展策略

### 1. 优先级原则

在进行样式扩展时，请遵循以下优先级原则：

```typescript
// 1. 优先使用主题令牌
const CustomButton = styled.button`
  background-color: ${({ theme }) => theme.tokens.colors.primary[500]};
  padding: ${({ theme }) => theme.tokens.spacing[3]}px;
`;

// 2. 其次使用主题计算值
const CustomCard = styled.div`
  background-color: ${({ theme }) => theme.colors.surface};
  color: ${({ theme }) => theme.colors.text.primary};
`;

// 3. 最后使用硬编码值（仅在必要时）
const SpecialComponent = styled.div`
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
`;
```

### 2. 扩展现有组件

#### 方法一：样式继承

```typescript
import { StyledButton } from '@flexi-ui/components/Button/Button.styled';

// 继承现有样式并扩展
export const CustomButton = styled(StyledButton)`
  border-radius: 50px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);

  &:hover {
    transform: translateY(-2px);
  }
`;
```

#### 方法二：组合模式

```typescript
import { Button } from '@flexi-ui/components';

// 创建包装组件
export const EnhancedButton: React.FC<ButtonProps & {
  gradient?: boolean;
}> = ({ gradient, ...props }) => {
  return (
    <ButtonWrapper gradient={gradient}>
      <Button {...props} />
    </ButtonWrapper>
  );
};

const ButtonWrapper = styled.div<{ gradient?: boolean }>`
  ${({ gradient, theme }) => gradient && css`
    background: linear-gradient(
      135deg,
      ${theme.tokens.colors.primary[400]},
      ${theme.tokens.colors.primary[600]}
    );
    border-radius: ${theme.tokens.radii.lg}px;
    padding: 2px;

    button {
      background: transparent;
      border: none;
    }
  `}
`;
```

### 3. 创建新的样式变体

```typescript
// 扩展现有变体系统
export const extendedVariantStyles = {
  ...variantStyles, // 导入现有变体

  gradient: (theme: Theme) => css`
    background: linear-gradient(
      135deg,
      ${theme.tokens.colors.primary[400]},
      ${theme.tokens.colors.secondary[400]}
    );
    color: white;
    border: none;

    &:hover {
      background: linear-gradient(
        135deg,
        ${theme.tokens.colors.primary[500]},
        ${theme.tokens.colors.secondary[500]}
      );
    }
  `,

  neon: (theme: Theme) => css`
    background: transparent;
    color: ${theme.tokens.colors.primary[400]};
    border: 2px solid ${theme.tokens.colors.primary[400]};
    box-shadow:
      0 0 10px ${theme.tokens.colors.primary[400]}40,
      inset 0 0 10px ${theme.tokens.colors.primary[400]}20;

    &:hover {
      box-shadow:
        0 0 20px ${theme.tokens.colors.primary[400]}60,
        inset 0 0 20px ${theme.tokens.colors.primary[400]}30;
    }
  `,
};
```

## 主题定制指南

### 1. 扩展设计令牌

```typescript
// 创建自定义令牌
export const customTokens = {
  ...designTokens,

  colors: {
    ...designTokens.colors,

    // 添加新的颜色系统
    brand: {
      50: '#f0f9ff',
      100: '#e0f2fe',
      200: '#bae6fd',
      300: '#7dd3fc',
      400: '#38bdf8',
      500: '#0ea5e9',
      600: '#0284c7',
      700: '#0369a1',
      800: '#075985',
      900: '#0c4a6e',
    },

    // 扩展语义颜色
    semantic: {
      ...designTokens.colors.semantic,
      brand: '#0ea5e9',
      accent: '#f59e0b',
    },
  },

  // 添加新的间距系统
  spacing: [
    ...designTokens.spacing,
    80,
    96,
    112,
    128, // 添加更大的间距值
  ],

  // 扩展字体系统
  typography: {
    ...designTokens.typography,

    fonts: {
      ...designTokens.typography.fonts,
      display: '"Playfair Display", serif',
      code: '"JetBrains Mono", monospace',
    },

    sizes: {
      ...designTokens.typography.sizes,
      '2xs': 10,
      '4xl': 36,
      '5xl': 48,
      '6xl': 60,
    },
  },
};
```

### 2. 创建主题变体

```typescript
// 创建特殊主题变体
export const createBrandTheme = (mode: 'light' | 'dark' = 'light') => {
  const baseTheme = createTheme(customTokens, mode);

  return {
    ...baseTheme,

    // 覆盖特定颜色
    colors: {
      ...baseTheme.colors,
      primary: customTokens.colors.brand,

      // 自定义背景色
      background: mode === 'light'
        ? customTokens.colors.brand[50]
        : customTokens.colors.neutral[900],

      // 自定义表面色
      surface: mode === 'light'
        ? 'white'
        : customTokens.colors.neutral[800]
    }
  };
};

// 使用自定义主题
export const BrandThemeProvider: React.FC<{ children: React.ReactNode }> = ({
  children
}) => {
  const [mode, setMode] = useState<'light' | 'dark'>('light');
  const theme = useMemo(() => createBrandTheme(mode), [mode]);

  return (
    <ThemeProvider theme={theme}>
      <ThemeContext.Provider value={{
        theme,
        mode,
        toggleMode: () => setMode(prev => prev === 'light' ? 'dark' : 'light'),
        setMode
      }}>
        {children}
      </ThemeContext.Provider>
    </ThemeProvider>
  );
};
```

### 3. 条件主题应用

```typescript
// 基于用户偏好的主题切换
export const useAdaptiveTheme = () => {
  const [userPreference, setUserPreference] = useState<
    'auto' | 'light' | 'dark'
  >('auto');
  const systemPrefersDark = useMediaQuery('(prefers-color-scheme: dark)');

  const effectiveMode = useMemo(() => {
    if (userPreference === 'auto') {
      return systemPrefersDark ? 'dark' : 'light';
    }
    return userPreference;
  }, [userPreference, systemPrefersDark]);

  const theme = useMemo(() => createBrandTheme(effectiveMode), [effectiveMode]);

  return {
    theme,
    mode: effectiveMode,
    userPreference,
    setUserPreference,
    toggleMode: () => {
      setUserPreference(prev => {
        if (prev === 'auto') return systemPrefersDark ? 'light' : 'dark';
        if (prev === 'light') return 'dark';
        return 'light';
      });
    },
  };
};
```

## 组件样式覆盖

### 1. CSS-in-JS 覆盖策略

```typescript
// 方法一：使用 styled 组件覆盖
export const CustomDataTable = styled(DataTable)`
  .data-table-header {
    background: linear-gradient(
      90deg,
      ${({ theme }) => theme.tokens.colors.primary[500]},
      ${({ theme }) => theme.tokens.colors.secondary[500]}
    );
    color: white;
  }

  .data-table-row {
    &:nth-child(even) {
      background-color: ${({ theme }) => theme.colors.surface};
    }

    &:hover {
      background-color: ${({ theme }) => theme.tokens.colors.primary[50]};
      transform: scale(1.01);
      transition: all 0.2s ease;
    }
  }
`;

// 方法二：使用 css prop 覆盖
export const CustomButton: React.FC<ButtonProps> = (props) => {
  return (
    <Button
      {...props}
      css={css`
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        border: none;
        color: white;

        &:hover {
          background: linear-gradient(45deg, #ff5252, #26c6da);
        }
      `}
    />
  );
};
```

### 2. 类名覆盖策略

```typescript
// 使用 className 进行样式覆盖
export const StyledButton = styled(Button).withConfig({
  shouldForwardProp: (prop) => prop !== 'customVariant'
})<{ customVariant?: 'neon' | 'glass' }>`
  &.custom-neon {
    background: transparent;
    border: 2px solid ${({ theme }) => theme.tokens.colors.primary[400]};
    color: ${({ theme }) => theme.tokens.colors.primary[400]};
    box-shadow: 0 0 20px ${({ theme }) => theme.tokens.colors.primary[400]}40;

    &:hover {
      box-shadow: 0 0 30px ${({ theme }) => theme.tokens.colors.primary[400]}60;
    }
  }

  &.custom-glass {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: ${({ theme }) => theme.colors.text.primary};
  }
`;

// 使用组件
<StyledButton className="custom-neon">霓虹按钮</StyledButton>
<StyledButton className="custom-glass">玻璃按钮</StyledButton>
```

### 3. 动态样式注入

```typescript
// 运行时样式注入
export const useDynamicStyles = (customStyles: Record<string, any>) => {
  return useMemo(() => {
    return css`
      ${Object.entries(customStyles).map(([property, value]) =>
        `${property}: ${value};`
      ).join('\n')}
    `;
  }, [customStyles]);
};

// 使用动态样式
export const DynamicButton: React.FC<ButtonProps & {
  customStyles?: Record<string, any>;
}> = ({ customStyles = {}, ...props }) => {
  const dynamicCss = useDynamicStyles(customStyles);

  return (
    <Button
      {...props}
      css={[
        css`
          /* 基础样式 */
          transition: all 0.3s ease;
        `,
        dynamicCss
      ]}
    />
  );
};

// 使用示例
<DynamicButton
  customStyles={{
    'background-color': '#ff6b6b',
    'border-radius': '50px',
    'box-shadow': '0 4px 12px rgba(255, 107, 107, 0.3)'
  }}
>
  动态样式按钮
</DynamicButton>
```

## 性能优化建议

### 1. 样式缓存优化

```typescript
// 创建样式缓存系统
class StyleCache {
  private cache = new Map<string, SerializedStyles>();
  private themeCache = new WeakMap<Theme, Map<string, SerializedStyles>>();

  getCachedStyle(
    key: string,
    factory: () => SerializedStyles
  ): SerializedStyles {
    if (!this.cache.has(key)) {
      this.cache.set(key, factory());
    }
    return this.cache.get(key)!;
  }

  getCachedThemeStyle(
    theme: Theme,
    key: string,
    factory: (theme: Theme) => SerializedStyles
  ): SerializedStyles {
    if (!this.themeCache.has(theme)) {
      this.themeCache.set(theme, new Map());
    }

    const cache = this.themeCache.get(theme)!;
    if (!cache.has(key)) {
      cache.set(key, factory(theme));
    }

    return cache.get(key)!;
  }

  clearCache() {
    this.cache.clear();
    this.themeCache = new WeakMap();
  }
}

export const styleCache = new StyleCache();

// 使用缓存的样式组件
export const CachedButton = styled.button<{ variant: string }>`
  ${({ theme, variant }) =>
    styleCache.getCachedThemeStyle(theme, `button-${variant}`, theme =>
      getVariantStyles(theme, variant)
    )}
`;
```

### 2. 条件渲染优化

```typescript
// 避免不必要的样式计算
export const OptimizedComponent = styled.div<{
  isActive?: boolean;
  variant?: 'primary' | 'secondary';
}>`
  /* 基础样式 */
  padding: ${({ theme }) => theme.tokens.spacing[4]}px;
  border-radius: ${({ theme }) => theme.tokens.radii.md}px;

  /* 条件样式 - 使用 CSS 变量优化 */
  --bg-color: ${({ theme, variant = 'primary' }) =>
    theme.tokens.colors[variant][500]};
  --text-color: ${({ theme, isActive }) =>
    isActive ? theme.colors.text.primary : theme.colors.text.secondary};

  background-color: var(--bg-color);
  color: var(--text-color);

  /* 避免复杂的条件逻辑 */
  ${({ isActive }) =>
    isActive &&
    css`
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    `}
`;
```

### 3. 样式分离策略

```typescript
// 将静态样式与动态样式分离
const staticStyles = css`
  display: flex;
  align-items: center;
  justify-content: center;
  border: none;
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  font-weight: 500;
  line-height: 1.5;
  text-decoration: none;
  transition: all 0.2s ease;
  user-select: none;
`;

const dynamicStyles = (theme: Theme, props: ButtonProps) => css`
  background-color: ${theme.tokens.colors[props.variant || 'primary'][500]};
  color: ${props.variant === 'outline'
    ? theme.tokens.colors.primary[500]
    : 'white'};
  padding: ${theme.tokens.spacing[props.size === 'sm' ? 2 : 3]}px
    ${theme.tokens.spacing[props.size === 'sm' ? 3 : 4]}px;
  border-radius: ${theme.tokens.radii[props.size === 'sm' ? 'sm' : 'md']}px;
`;

export const PerformantButton = styled.button<ButtonProps>`
  ${staticStyles}
  ${({ theme, ...props }) => dynamicStyles(theme, props)}
`;
```

## 常见问题解决

### 1. 样式优先级问题

```typescript
// 问题：样式被覆盖
const ProblemButton = styled.button`
  background-color: red; // 可能被主题样式覆盖
`;

// 解决方案：使用 !important 或提高特异性
const SolutionButton = styled.button`
  && {
    background-color: red; // 提高特异性
  }

  /* 或者 */
  background-color: red !important; // 使用 !important
`;

// 更好的解决方案：使用主题系统
const BetterButton = styled.button`
  background-color: ${({ theme }) => theme.tokens.colors.red[500]};
`;
```

### 2. 主题切换闪烁问题

```typescript
// 问题：主题切换时出现闪烁
export const FlickerButton = styled.button`
  background-color: ${({ theme }) => theme.colors.surface};
  color: ${({ theme }) => theme.colors.text.primary};
`;

// 解决方案：使用 CSS 变量
export const SmoothButton = styled.button`
  background-color: var(--surface-color);
  color: var(--text-primary-color);
  transition: background-color 0.2s ease, color 0.2s ease;
`;

// 在主题提供者中设置 CSS 变量
export const ThemeVariableProvider: React.FC<{ children: React.ReactNode }> = ({
  children
}) => {
  const { theme } = useTheme();

  useEffect(() => {
    const root = document.documentElement;
    root.style.setProperty('--surface-color', theme.colors.surface);
    root.style.setProperty('--text-primary-color', theme.colors.text.primary);
    // ... 设置其他变量
  }, [theme]);

  return <>{children}</>;
};
```

### 3. 类型安全问题

```typescript
// 问题：缺少类型定义
const UnsafeButton = styled.button<any>`
  background-color: ${({ variant, theme }) =>
    theme.tokens.colors[variant][500]}; // 可能出现运行时错误
`;

// 解决方案：完整的类型定义
interface SafeButtonProps {
  variant?: keyof typeof designTokens.colors;
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
}

const SafeButton = styled.button<SafeButtonProps>`
  background-color: ${({ variant = 'primary', theme }) =>
    theme.tokens.colors[variant][500]};

  ${({ size = 'md', theme }) => {
    const sizeMap = {
      sm: theme.tokens.spacing[2],
      md: theme.tokens.spacing[3],
      lg: theme.tokens.spacing[4],
    };
    return css`
      padding: ${sizeMap[size]}px;
    `;
  }}

  ${({ disabled, theme }) =>
    disabled &&
    css`
      opacity: 0.5;
      cursor: not-allowed;
      background-color: ${theme.colors.text.disabled};
    `}
`;
```

## 开发工具和调试

### 1. 样式调试工具

```typescript
// 开发环境样式调试
export const DebugWrapper = styled.div<{ debug?: boolean }>`
  ${({ debug }) => debug && css`
    * {
      outline: 1px solid red !important;
      outline-offset: -1px;
    }

    *:hover {
      outline-color: blue !important;
    }
  `}
`;

// 主题调试信息
export const ThemeDebugger: React.FC = () => {
  const { theme, mode } = useTheme();

  if (process.env.NODE_ENV !== 'development') {
    return null;
  }

  return (
    <DebugPanel>
      <h3>主题调试信息</h3>
      <p>当前模式: {mode}</p>
      <details>
        <summary>主题对象</summary>
        <pre>{JSON.stringify(theme, null, 2)}</pre>
      </details>
    </DebugPanel>
  );
};

const DebugPanel = styled.div`
  position: fixed;
  top: 10px;
  right: 10px;
  background: white;
  border: 1px solid #ccc;
  padding: 16px;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  max-width: 300px;
  max-height: 400px;
  overflow: auto;
  z-index: 9999;
  font-size: 12px;
`;
```

### 2. 样式性能监控

```typescript
// 样式性能监控
export const useStylePerformance = () => {
  const [metrics, setMetrics] = useState({
    renderTime: 0,
    styleCalculationTime: 0,
    recomputeCount: 0
  });

  useEffect(() => {
    if (process.env.NODE_ENV !== 'development') return;

    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry) => {
        if (entry.name.includes('style')) {
          setMetrics(prev => ({
            ...prev,
            styleCalculationTime: entry.duration,
            recomputeCount: prev.recomputeCount + 1
          }));
        }
      });
    });

    observer.observe({ entryTypes: ['measure'] });

    return () => observer.disconnect();
  }, []);

  return metrics;
};

// 性能监控组件
export const StylePerformanceMonitor: React.FC<{ children: React.ReactNode }> = ({
  children
}) => {
  const metrics = useStylePerformance();

  return (
    <>
      {children}
      {process.env.NODE_ENV === 'development' && (
        <PerformancePanel>
          <h4>样式性能</h4>
          <p>样式计算时间: {metrics.styleCalculationTime.toFixed(2)}ms</p>
          <p>重计算次数: {metrics.recomputeCount}</p>
        </PerformancePanel>
      )}
    </>
  );
};
```

### 3. 样式文档生成

```typescript
// 自动生成样式文档
export const generateStyleDocs = (component: React.ComponentType) => {
  const componentName = component.displayName || component.name;
  const styledComponent = component as any;

  if (!styledComponent.styledComponentId) {
    console.warn(`${componentName} is not a styled component`);
    return;
  }

  // 提取样式信息
  const styles = styledComponent.componentStyle?.rules || [];

  return {
    componentName,
    styledComponentId: styledComponent.styledComponentId,
    styles: styles.map((rule: any) => ({
      type: typeof rule,
      content: rule.toString()
    })),
    props: extractPropsFromComponent(component)
  };
};

// 样式文档展示组件
export const StyleDocumentation: React.FC<{
  component: React.ComponentType;
}> = ({ component }) => {
  const docs = generateStyleDocs(component);

  if (!docs) return null;

  return (
    <DocContainer>
      <h3>{docs.componentName} 样式文档</h3>
      <section>
        <h4>样式规则</h4>
        {docs.styles.map((style, index) => (
          <CodeBlock key={index}>
            <pre>{style.content}</pre>
          </CodeBlock>
        ))}
      </section>
    </DocContainer>
  );
};
```

## 总结

通过遵循这些最佳实践，你可以：

1. **高效扩展样式**: 利用现有的主题系统和设计令牌
2. **保持性能**: 避免不必要的样式重计算和渲染
3. **确保一致性**: 遵循设计系统的约定和模式
4. **提高可维护性**: 使用类型安全和模块化的方法
5. **优化开发体验**: 利用调试工具和性能监控

记住，样式扩展的关键是在灵活性和性能之间找到平衡，始终优先考虑用户体验和代码可维护性。
