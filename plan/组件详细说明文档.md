# Flexi-UI 组件详细说明文档

## 概述

Flexi-UI 是一个基于 React 和 TypeScript 构建的现代化 UI 组件库，采用 CSS-in-JS（Emotion）进行样式管理，提供了丰富的组件和 hooks，支持主题切换、虚拟滚动、表单管理等高级功能。

## 核心组件

### 1. Button 组件

#### 功能特性

- 支持多种视觉变体：`primary`、`secondary`、`outline`、`ghost`
- 三种尺寸规格：`sm`、`md`、`lg`
- 内置加载状态和 Spinner 动画
- 支持图标和全宽度布局
- 完整的无障碍访问支持（focus-visible）
- 基于 forwardRef 的 ref 转发

#### 技术实现

- 使用 `@emotion/styled` 进行样式管理
- 采用主题系统（Theme Tokens）统一设计规范
- 支持 CSS-in-JS 的动态样式计算
- 响应式设计和交互状态管理

#### 使用示例

```tsx
import { Button } from 'flexi-ui';

// 基础用法
<Button variant="primary" size="md">
  点击按钮
</Button>

// 带图标和加载状态
<Button
  variant="outline"
  icon={<Icon />}
  loading={isLoading}
  onClick={handleClick}
>
  提交表单
</Button>
```

#### API 接口

```typescript
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  loading?: boolean;
  icon?: ReactNode;
  fullWidth?: boolean;
  children?: ReactNode;
}
```

### 2. DataTable 组件

#### 功能特性

- **高性能数据展示**：支持大数据量虚拟滚动
- **完整的数据操作**：排序、筛选、分页功能
- **行选择机制**：单选/多选支持
- **自定义渲染**：灵活的单元格内容定制
- **响应式设计**：适配不同屏幕尺寸
- **加载状态**：骨架屏和异步数据处理

#### 技术架构

- **三层数据处理管道**：筛选 → 排序 → 分页
- **状态管理优化**：使用 useMemo 缓存计算结果
- **虚拟滚动集成**：与 VirtualList 组件深度整合
- **类型安全**：完整的 TypeScript 泛型支持

#### 核心实现细节

##### 数据处理流程

```typescript
// 第一层：数据筛选
const filteredData = useMemo(() => {
  return data.filter(item => {
    return Object.entries(filters).every(([key, value]) => {
      if (!value) return true;
      const itemValue = String(item[key]).toLowerCase();
      return itemValue.includes(String(value).toLowerCase());
    });
  });
}, [data, filters]);

// 第二层：数据排序
const sortedData = useMemo(() => {
  if (sorting.length === 0) return filteredData;
  return [...filteredData].sort((a, b) => {
    for (const sort of sorting) {
      const aVal = a[sort.key];
      const bVal = b[sort.key];
      if (aVal < bVal) return sort.direction === 'asc' ? -1 : 1;
      if (aVal > bVal) return sort.direction === 'asc' ? 1 : -1;
    }
    return 0;
  });
}, [filteredData, sorting]);

// 第三层：数据分页
const paginatedData = useMemo(() => {
  if (!pagination) return sortedData;
  const start = (currentPage - 1) * pagination.pageSize;
  const end = start + pagination.pageSize;
  return sortedData.slice(start, end);
}, [sortedData, currentPage, pagination]);
```

##### 虚拟滚动优化

```typescript
const TableBody = useMemo(() => {
  // 当启用虚拟滚动且数据量超过 100 条时，使用虚拟列表
  if (virtualScroll && paginatedData.length > 100) {
    return (
      <VirtualList
        data={paginatedData}
        containerHeight={400}
        itemHeight={48}
        renderItem={(row: T, index?: number) => (
          <TableRow
            key={String(row[rowKey])}
            record={row}
            columns={processedColumns}
            // ... 其他属性
          />
        )}
      />
    );
  }
  // 普通渲染模式
  return (/* 标准行渲染 */);
}, [paginatedData, processedColumns, /* 其他依赖 */]);
```

#### 使用示例

```tsx
import { DataTable } from 'flexi-ui';

interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

const columns: Column<User>[] = [
  {
    key: 'name',
    title: '姓名',
    sortable: true,
    filterable: true,
  },
  {
    key: 'email',
    title: '邮箱',
    render: (value, record) => <a href={`mailto:${value}`}>{value}</a>,
  },
  {
    key: 'age',
    title: '年龄',
    sortable: true,
    width: 100,
  },
];

<DataTable
  data={users}
  columns={columns}
  rowKey="id"
  pagination={{ pageSize: 20 }}
  virtualScroll={true}
  selectable={true}
  onRowSelect={handleRowSelect}
/>;
```

#### API 接口

```typescript
export interface Column<T> {
  key: keyof T;
  title: string;
  width?: number;
  sortable?: boolean;
  filterable?: boolean;
  sortDirection?: 'asc' | 'desc';
  filterValue?: unknown;
  render?: (value: unknown, record: T, index: number) => React.ReactNode;
}

export interface DataTableProps<T> {
  data: T[];
  columns: Column<T>[];
  rowKey: keyof T;
  pagination?: {
    pageSize: number;
    showSizeChanger?: boolean;
  };
  loading?: boolean;
  onRowSelect?: (selectedRows: T[]) => void;
  virtualScroll?: boolean;
  selectable?: boolean;
  className?: string;
}
```

### 3. FileUploader 组件

#### 功能特性

- **分片上传**：支持大文件分块上传，提高上传成功率
- **断点续传**：网络中断后可继续上传未完成的分片
- **并发控制**：可配置最大并发上传数量
- **文件哈希**：使用 MD5 生成文件唯一标识
- **拖拽上传**：支持拖拽文件到上传区域
- **进度显示**：实时显示上传进度和状态
- **主题适配**：支持亮色/暗色主题切换

#### 技术实现

##### 文件分片机制

```typescript
// 文件分片
const createFileChunks = (file: File): Blob[] => {
  const chunks: Blob[] = [];
  let start = 0;

  while (start < file.size) {
    const end = Math.min(start + chunkSize, file.size);
    chunks.push(file.slice(start, end));
    start = end;
  }

  return chunks;
};
```

##### 哈希生成

```typescript
// 生成文件哈希
const generateFileHash = async (file: File): Promise<string> => {
  const crypto = await import('crypto-js');
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => {
      const arrayBuffer = e.target?.result as ArrayBuffer;
      const wordArray = crypto.lib.WordArray.create(arrayBuffer);
      const hash = crypto.MD5(wordArray).toString();
      resolve(hash);
    };
    reader.readAsArrayBuffer(file);
  });
};
```

##### 断点续传

```typescript
// 检查已上传的分片
const checkUploadedChunks = async (hash: string): Promise<number[]> => {
  const response = await fetch(getApiUrl('check'), {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ hash }),
  });

  if (response.ok) {
    const data = await response.json();
    return data.uploadedChunks || [];
  }
  return [];
};
```

#### 使用示例

```tsx
import { FileUploader } from 'flexi-ui';

<FileUploader
  action="/api/upload"
  urls={{
    check: '/api/upload/check',
    chunk: '/api/upload/chunk',
    merge: '/api/upload/merge',
  }}
  multiple={true}
  chunkSize={2 * 1024 * 1024} // 2MB
  maxConcurrent={3}
  accept="image/*,.pdf,.doc,.docx"
  maxSize={100 * 1024 * 1024} // 100MB
  onProgress={(file, progress) => {
    console.log(`${file.name}: ${progress}%`);
  }}
  onSuccess={(file, response) => {
    console.log('上传成功:', file.name);
  }}
  onError={(file, error) => {
    console.error('上传失败:', error);
  }}
/>;
```

#### API 接口

```typescript
interface UploadUrls {
  check: string; // 检查已上传分片的接口URL
  chunk: string; // 上传分片的接口URL
  merge: string; // 合并分片的接口URL
}

export interface UploadFile {
  uid: string;
  name: string;
  size: number;
  type: string;
  status: 'ready' | 'uploading' | 'success' | 'error' | 'paused';
  progress: number;
  file: File;
  chunks?: Blob[];
  uploadedChunks?: boolean[];
  hash?: string;
}

interface FileUploaderProps {
  action: string;
  urls?: UploadUrls;
  multiple?: boolean;
  chunkSize?: number;
  maxConcurrent?: number;
  accept?: string;
  maxSize?: number;
  onProgress?: (file: UploadFile, progress: number) => void;
  onSuccess?: (file: UploadFile, response: unknown) => void;
  onError?: (file: UploadFile, error: Error) => void;
  beforeUpload?: (file: File) => boolean | Promise<boolean>;
  className?: string;
}
```

### 4. VirtualList 组件

#### 功能特性

- **高性能渲染**：只渲染可视区域内的元素
- **动态高度支持**：自动计算和缓存每个项目的实际高度
- **平滑滚动**：使用节流优化滚动性能
- **预渲染机制**：通过 overscan 参数预渲染额外项目
- **内存优化**：避免大量 DOM 节点造成的性能问题

#### 技术实现

##### 可视区域计算

```typescript
const [startIndex, endIndex, totalHeight] = useMemo<
  [number, number, number]
>(() => {
  if (!data || !Array.isArray(data) || data.length === 0) {
    return [0, 0, 0];
  }

  let total = 0;
  let start = 0;
  let end = data.length;

  // 找出可视区域起点
  for (let i = 0; i < data.length; i++) {
    const h = itemHeights[i] || itemHeight;
    if (total + h >= scrollTop) {
      start = Math.max(0, i - overscan);
      break;
    }
    total += h;
  }

  // 继续找出可视区域终点
  let visibleHeight = 0;
  for (let i = start; i < data.length; i++) {
    visibleHeight += itemHeights[i] || itemHeight;
    if (visibleHeight >= containerHeight) {
      end = Math.min(data.length, i + overscan * 2);
      break;
    }
  }

  const allHeight = data.reduce((acc, _, index) => {
    return acc + (itemHeights[index] || itemHeight);
  }, 0);

  return [start, end, allHeight];
}, [itemHeight, scrollTop, itemHeights, data, overscan, containerHeight]);
```

##### 动态高度处理

```typescript
const updateHeight = useCallback((index: number, height: number) => {
  setItemHeights(prev => {
    if (prev[index] === height) return prev;
    return { ...prev, [index]: height };
  });
}, []);

// 在渲染时测量实际高度
<VirtualListItem
  key={getKey?.(item) ?? index}
  ref={ref => {
    if (ref) {
      const h = ref.offsetHeight;
      if (h && itemHeights[index] !== h) {
        updateHeight(index, h);
      }
    }
  }}
>
  {renderItem(item, index)}
</VirtualListItem>
```

#### 使用示例

```tsx
import { VirtualList } from 'flexi-ui';

const data = Array.from({ length: 10000 }, (_, i) => ({
  id: i,
  name: `Item ${i}`,
  description: `Description for item ${i}`,
}));

<VirtualList
  data={data}
  containerHeight={400}
  itemHeight={70}
  overscan={5}
  getKey={item => item.id}
  renderItem={item => (
    <div key={item.id}>
      <h3>{item.name}</h3>
      <p>{item.description}</p>
    </div>
  )}
/>;
```

#### API 接口

```typescript
interface VirtualListProps<T> {
  data: T[];
  itemHeight?: number;
  containerHeight?: number;
  overscan?: number;
  getKey?: (item: T) => number | string;
  renderItem: (item: T, index?: number) => ReactNode;
  className?: string;
}
```

### 5. ThemeToggle 组件

#### 功能特性

- **主题切换**：在亮色和暗色主题间切换
- **图标适配**：根据当前主题显示对应的太阳/月亮图标
- **自定义内容**：支持自定义按钮文本和样式
- **无障碍支持**：提供清晰的视觉反馈和语义化标签

#### 技术实现

```typescript
export const ThemeToggle: React.FC<ThemeToggleProps> = ({
  children,
  className,
}) => {
  const { mode, toggleMode } = useTheme();

  const getIcon = () => {
    if (mode === 'light') {
      return (
        <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
          {/* 月亮图标 SVG 路径 */}
        </svg>
      );
    } else {
      return (
        <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
          {/* 太阳图标 SVG 路径 */}
        </svg>
      );
    }
  };

  return (
    <Button
      variant="outline"
      size="md"
      onClick={toggleMode}
      icon={getIcon()}
      className={className}
    >
      {children || `切换到${mode === 'light' ? '暗色' : '亮色'}模式`}
    </Button>
  );
};
```

#### 使用示例

```tsx
import { ThemeToggle } from 'flexi-ui';

// 基础用法
<ThemeToggle />

// 自定义文本
<ThemeToggle>
  切换主题
</ThemeToggle>

// 自定义样式
<ThemeToggle className="custom-theme-toggle">
  主题
</ThemeToggle>
```

#### API 接口

```typescript
interface ThemeToggleProps {
  children?: ReactNode;
  className?: string;
}
```

## 组件设计原则

### 1. 类型安全

- 所有组件都使用 TypeScript 编写
- 提供完整的类型定义和泛型支持
- 严格的类型检查确保运行时安全

### 2. 性能优化

- 使用 React.memo、useMemo、useCallback 优化渲染
- 虚拟滚动处理大数据量场景
- 节流和防抖优化用户交互

### 3. 可访问性

- 遵循 WCAG 2.1 无障碍访问标准
- 提供键盘导航支持
- 语义化 HTML 结构

### 4. 主题系统

- 统一的设计令牌（Design Tokens）
- 支持亮色/暗色主题切换
- CSS-in-JS 动态样式计算

### 5. 组合性

- 组件间松耦合设计
- 支持组合使用和扩展
- 一致的 API 设计模式

## 样式系统

### CSS-in-JS 架构

使用 `@emotion/styled` 和 `@emotion/react` 构建样式系统：

```typescript
// 基础样式模式
const baseButtonStyles = (theme: Theme) => css`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: none;
  border-radius: ${theme.tokens.radii.md};
  font-family: ${theme.tokens.typography.fonts.body};
  transition: all ${theme.tokens.transitions.fast};
`;

// 变体样式
const variantStyles = (theme: Theme) => ({
  primary: css`
    background-color: ${theme.tokens.colors.primary[500]};
    color: white;
    &:hover:not(:disabled) {
      background-color: ${theme.tokens.colors.primary[600]};
    }
  `,
  // 其他变体...
});
```

### 主题令牌系统

```typescript
export const designTokens = {
  colors: {
    primary: { 50: '#eff6ff', 500: '#3b82f6', 900: '#1e3a8a' },
    secondary: {
      /* 完整色阶 */
    },
    semantic: {
      success: '#10b981',
      warning: '#f59e0b',
      error: '#ef4444',
      info: '#3b82f6',
    },
  },
  spacing: [0, 4, 8, 12, 16, 24, 32, 48, 64, 96],
  typography: {
    fonts: {
      body: 'Inter, system-ui, -apple-system, sans-serif',
      mono: 'Fira Code, Consolas, monospace',
    },
    sizes: [12, 14, 16, 18, 20, 24, 30, 36, 48, 60, 72],
    weights: { normal: 400, medium: 500, semibold: 600, bold: 700 },
  },
  // 更多令牌...
};
```

## 测试策略

### 单元测试

- 使用 Vitest 进行单元测试
- 每个组件都有对应的测试文件
- 覆盖组件的主要功能和边界情况

### 集成测试

- 测试组件间的交互
- 验证主题切换功能
- 测试表单验证流程

### 性能测试

- 虚拟滚动性能基准测试
- 大数据量场景下的渲染性能
- 内存使用情况监控

## 最佳实践

### 1. 组件使用

```tsx
// ✅ 推荐：使用类型安全的方式
interface User {
  id: number;
  name: string;
  email: string;
}

const UserTable: React.FC = () => {
  const [users, setUsers] = useState<User[]>([]);

  return (
    <DataTable<User>
      data={users}
      columns={columns}
      rowKey="id"
      virtualScroll={users.length > 100}
    />
  );
};

// ❌ 避免：缺少类型定义
const BadTable = () => {
  const [data, setData] = useState([]);
  return <DataTable data={data} columns={[]} />;
};
```

### 2. 性能优化

```tsx
// ✅ 推荐：使用 memo 优化渲染
const OptimizedComponent = React.memo(({ data, onSelect }) => {
  const memoizedColumns = useMemo(() => createColumns(), []);

  return (
    <DataTable data={data} columns={memoizedColumns} onRowSelect={onSelect} />
  );
});

// ❌ 避免：每次渲染都创建新对象
const BadComponent = ({ data, onSelect }) => {
  return (
    <DataTable
      data={data}
      columns={createColumns()} // 每次都创建新数组
      onRowSelect={onSelect}
    />
  );
};
```

### 3. 主题使用

```tsx
// ✅ 推荐：使用主题令牌
const StyledComponent = styled.div`
  color: ${({ theme }) => theme.tokens.colors.primary[500]};
  padding: ${({ theme }) => theme.tokens.spacing[4]}px;
`;

// ❌ 避免：硬编码样式值
const BadStyledComponent = styled.div`
  color: #3b82f6;
  padding: 16px;
`;
```

## 总结

Flexi-UI 组件库通过现代化的技术栈和设计理念，提供了一套完整、高性能、类型安全的 React 组件解决方案。每个组件都经过精心设计，注重性能优化、可访问性和开发体验，能够满足现代 Web 应用的各种需求。
